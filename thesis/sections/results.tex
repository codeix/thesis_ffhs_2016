\chapter{Resultate}

\section{Beschreibung der Daten}

Die Daten wurden automatisiert, wie im \autoref{sec:automatisierung} beschrieben, aufgezeichnet und als Diagramme dargestellt. Die Resultate befinden sich im Anhang dieser Arbeit. Die Beschreibung zu den Daten sind wie folgt zu interpretieren:

\begin{description}
\item[Titel:]
Der Titel entspricht dem Benchmark das ausgeführt wurde. Der Name vordem Unterstrich ist auch der Befehlssatz, dass für den Benchmark verwendet worden ist. Wenn nach dem Unterstrich eine Zahl steht, definiert sie wie viele Bit das 32Bit-Register ausfüllt. Folglich steht z.B. für die Zahl 8 für die hexadezimale Zahl 0x000000FF.
\item[Beschreibung:]
Jeder Benchmark besitzt eine Beschreibung die unmittelbar nach dem Titel steht. Die in kursiv geschriebene \texttt{CSV-Datei} definiert welche Daten für die Diagramme verwendet worden sind. Die Daten wurden im CSV-gespeichert und sind unter folgende URL zu finden: \url{https://github.com/codeix/thesis_ffhs_2016/tree/master/results}. Die Dateien sind entsprechend dem verwendeten Board in die Unterverzeichnisse \texttt{galileodata} und \texttt{raspberrydata} unterteilt. 
\item[Diagramme:]
Die Daten sind als Liniendiagramm dargestellt. Jeder Benchmark wurde drei Mal ausgeführt, deswegen werden die Daten in drei Säulen dargestellt. Die Achsen wurden so ausgewählt, dass sie den Ausschnitt der relevanten Daten aufzeigen und möglichst viel Platz sparen.
\item[Durchschnitt und Median:]
In der selbe Säule des Diagramm sind die Werte des Durchschnitt und Median aufgeführt. Beschriftet sind sie auf Englisch mit \texttt{Average} und \texttt{Median}.
\item[Durchlaufzeit:]
Mit \texttt{Exec time} ist die Durchlaufzeit des Benchmark in Millisekunden aufgeführt. Da dieser Wert direkt vom Benchmark stammt, ist er genauer als der im Diagramm (Die Amperemessung wurde mit einer separater Uhr im Multimeter aufgezeichnet).
\item[Reihenfolge:] Die Reihenfolge die mit \texttt{Exec order} bezeichnet ist, bestimmt in welche Folge die Daten aufgenommen worden sind. Die Benchmarks wurden nach einer Zufälliger Reihenfolge ausgeführt.

\end{description}



\section{Prüfung der Daten}

Es ist wichtig die Daten nach der Richtigkeit zu prüfen. Um die Korrektheit unter Beweis zu stellen können Folgende Prüfkriterien erstellt werden.
\par
Als erstes wird der Verlauf der Daten, für jeden einzelnen Benchmark angeschaut. Während der Ausführung des Benchmark wurden ca. 200 Messungen vorgenommen. Diese sind auf einer Zeitachse und in einem Liniendiagramm dargestellt. Dabei kann man beobachten, dass sich die Linie gerade verläuft. Dies bestätigt, das der Benchmark einen wiederholender Ablauf ausführt und dadurch einen konstanten Stromverbrauch verursacht. Als zweiten Kriterium kann die drei Ausführungen eines einzelnen Benchmark gegenüber gestellt und Ausgewertet werden. Jeder Benchmark wurde drei Mal ausgeführt wobei die Reihenfolge aller Benchmarks zufällig war. Durch die Gegenüberstellung wird ersichtlich, dass sowohl Zeit wie auch der Median des Stromverbrauchs, mit Vorbehalt von Rundungsfehler, derselbe entspricht. Dies Beweist das innerhalb der selben Benchmarks keine Abweichung entstehen. Als letztes Prüfkriterium können die drei Benchmarks \texttt{nop}, \texttt{nop\_nop} und \texttt{nop\_nop\_nop} in Betracht gezogen werden. Der Benchmark \texttt{nop} ist eine leere Befehlszeile in einer Schlaufe. Er verbraucht bei der Ausführung ein CPU-Zyklus bei jedem Schlaufendurchlauf. Der Benchmark \texttt{nop\_nop} verbraucht zwei und der Benchmark \texttt{nop\_nop\_nop} drei CPU-Zyklen. Wird die Durchlaufszeit dieser drei Benchmarks Nebeneinander dargestellt, kann beobachtet werden, dass die Durchlaufzeit linear wächst. Durch diese Beobachtung kann man Prüfen wie viel Zeit ein CPU-Zyklus verwendet, wann man die Durchlaufzeit der Schlaufe abzählt.
\par
Das letzte Kriterium kann durch eine einfache Rechnung unter Beweis gestellt werden. Die beiden Benchmarks \texttt{nop} und \texttt{nop\_nop} besteht aus einer Schlaufe und einem oder zwei leeren Befehlssätze. Durch eine Subtraktion der beiden erhalten wir die Durchlaufzeit des leeren Befehlssatz. Also genau einen CPU-Zyklus mal die Anzahl der Schlaufendurchläufe. Durch eine Inter- und Extrapolation kann man überprüfen ob es sich mit der Prozessortaktfrequenz des Herstellers übereinstimmt. Die Taktfrequenz des Galileo Board Beträgt 400 MHz. Über die Kommandozeile mit dem Befehl \texttt{lscpu} kann der genau Wert heraus gelesen werden, der mit 399.076MHz ein wenig tiefer liegt.

\[ \left(\frac{t_2-t_1}{n}\right)^{-1} =  \left(\frac{(145'292-129'147)/1'000}{6'442'450'944}\right)^{-1} \approx 399'000'000 \]

Diese Berechnung kann nicht für jede Architektur eines CPU verwendet werden. Wird die selbe Berechnung auf einem ARM Prozessor mit 700MHz eines RaspberryPI Board angewendet bekommt man eine Zahl die etwa doppelt so hoch ist als die Taktfrequenz.
\[ \left(\frac{t_2-t_1}{n}\right)^{-1} =  \left(\frac{(123'559-108'112)/1'000}{21'474'836'480}\right)^{-1} \approx 1'390'000'000 \]
Werden die drei Benchmarks \texttt{nop}, die auf den RaspberryPI Board angewendet worden sind gegenüberstellt, kann man beobachten das sie sich nicht Linear vergrössern. Dies liegt daran, dass moderne CPUs interne Optimierungen besitzen. So werden Befehlssätze wenn möglich parallel ausgeführt. Die Anzahl über die genau verwendeten Zyklen ist sehr schwer berechenbar. Dies zeigt auch folgendes Zitat aus der Dokumentation von ARM für den ARM1176JZF-S Prozessor.

\begin{quotation}
\enquote{Complex instruction dependencies and memory system interactions make it impossible to
describe briefly the exact cycle timing of all instructions in all circumstances.}
\par
...
\par
\enquote{ If precise timings are required you must use a cycle-accurate model of the processor.\cite{arm_datasheet}}
\end{quotation}



\section{Auswertung der Resultate}
\label{sec:auswertung_resultate}

Um eine Aussage zu machen welcher Benchmark und der damit verbundener Befehlssatz mehr Energie verbraucht. Wurden die sie in einem Balkendiagramm gegenüber gestellt. Diese sind für das Galileo Board in \autoref{fig:benchmarks_galileo} und für das Raspberry in \autoref{fig:benchmarks_rasp} ersichtlich. Aus der Erhebung der Daten die im \autoref{sec:automatisierung} beschrieben sind, bekommt man die Durchlaufszeit und Stromverbrauch jedes einzelnen Benchmark. Beide CPU-Architekturen auf denen die Benchmarks ausgeführt wurden, haben unterschiedliche Durchlaufzeiten für jeweils einen Befehlssatz der getestet wird. Der Energieverbrauch entspricht der Leistung mal die beanspruchte Zeit. Die Darstellung der Balkendiagramme wurde Absichtlich so gewählt, dass Leistung und Durchlaufzeit ersichtlich sind. Jeder Benchmark wurde drei Mal ausgeführt, um die Leistung zu bestimmen wurde der Medien der Benchmark berechnet und durch die Spannung des Spannungsregler multipliziert. Um den gewünschten EPI, also Energieverbrauch pro Befehlssatz zu Berechnen, sind zwei weitere Schritte notwendig die in den Diagrammen nicht mehr ersichtlich sind. Als erster Schritt, muss die Energie Berechnet werden. Die Energie berechnet sich durch die Leistung mal die Zeit die ein Benchmark benötigt hat um durch zu laufen. Man erhält den Energie verbrauch pro Benchmark. Der Benchmark besteht aber aus einer Schlaufe der einen bestimmten Befehlssatz mehrere Milliarden Male ausführt. Um die Energie pro Befehlssatz zu bestimmen muss als letzter Schritt die gesamt Energie durch die Anzahl Durchläufe des Benchmark dividiert werden. Dieser Schritt bestimmt den Energieverbrauch pro Schleifendurchlauf. Da die Schleife selbst eine bestimmte Grundenergie benötigt muss vorerst abgerechnet werden. Auf das Problem der Bestimmung der Grundenergie der Schleife wird auf im \autoref{sec:bestimmung_grundenergie} noch einmal eingegangen. Die folgende Formel zeigt die Berechnung des EPI.

\[ \frac{\textnormal{Strom} * \textnormal{Spannung} * \textnormal{Zeit} - \textnormal{Grundenergie der Schleife}}{\textnormal{Anzahl Durchl{\"a}ufe}} = \textnormal{EPI} \]



\input{sections/diagrams/galileo_results}


\input{sections/diagrams/raspberry_results}


\section{Beobachtung}

Betrachtet man die Durchlaufzeit wird ersichtlich das sie Stufen auf einer Ratioskala bilden. Die Intervalle können als CPU-Zyklus erklärt werden, dabei nimmt ein CPU-Zyklus immer gleich viel Zeit in Anspruch. Aus den Stufen die die Durchlaufzeit wiedergibt, ist es möglich Kategorien zu bilden und ein Befehlssatz ein, zwei oder mehrere CPU-Zyklen zu zuteilen. Je nach Prozessor Architektur und Komplexität des Befehlssatz, benötigt es für die Abarbeitung mehrere CPU-Zyklen. Dazu kommt, dass moderne Prozessoren fähig sind mehrere Befehlssätze gleichzeitig auf einem Single-Core auszuführen. Wobei sehr komplexe Kriterien erfühlt sein müssen, die vom Hersteller nicht immer gegeben sind.
\par
Wie bereits im \autoref{sec:auswertung_resultate} ist die Energie eine Zusammensetzung von Leistung und Zeit. Die Zeit stellt eigentlich den grössten Stromverbraucher dar. Denn die Leistungsunterschiede innerhalb einer Zyklen-Kategorie ist vernachlässigbar klein gegen über einer Höheren Kategorie.
\par
Innerhalb ähnliche Zyklen-Kategorien wie z.B. die Daten vom Raspberry Board \texttt{add\_0} und \texttt{add\_32} oder die vom Galileo Board \texttt{addl\_0} und \texttt{addl\_32} zeigen die durchaus einen Messbaren Leistungsunterschied. Es geht hervor, dass das Galileo Board einen grösseren Leistungsverbrauch einer Addition mit grösseren Zahlen als mit kleineren hat. Beim Raspberry Board ist diese Beobachtung gerade umgekehrt. Um die Ursache zu finden müsste an dieser Stelle weitere Forschung angestrebt werden.
\par
Wird der Fokus auf beide Benchmark \texttt{add\_32} und \texttt{sadd16\_8} gelegt die auf dem Raspberry Board ausgeführt wurden. Kann man erkennen,  dass eine die Additionsoperation die parallel zwei Mal eine Zahl von 16-Bit rechnen kann, weniger Leistung in Anspruch nimmt als die Additionsoperation für eine 32-Bit Zahl. Wäre es also möglich für Zahlen bis zu einer Grösse von 16-Bit, konsequent die Assemblerinstruktion \texttt{sadd16} anstelle von \texttt{add} zu wählen, ergäbe es sich womöglich ein Sparpotenzial. Die beide Benchmarks haben je ein Verbrauch von 2.263W und 2.231W. Das Ersparnispotenzial wäre also 32mW oder ca. 1.4\%. Dabei ist aber zu Beachten, dass das Ersparnis erst bei 21 Milliarden Durchläufe erreicht wird. Was allerdings je nach Anwendung schnell erreicht ist, wenn z.B. an die Pixelberechnung eines Bild denkt.
\par















