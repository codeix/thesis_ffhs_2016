\chapter{Diskussion}


\section{Messung der unterschiedlichen CPUs Architekturen}
Im Bezug auf die Umwelt und das streben nach einer Energieeinsparung, zeigt diese Arbeit, dass es möglich ist einzelne Befehlssätze zu messen und auszuwerten. Es zeigt aber auch wie unterschiedlich die Verschiedene Architekturen sind und wie sie sich deshalb die Benchmarks komplett anderes ausgewirkt haben. Es ist anzunehmen, dass die erzeugten Daten der Benchmarks nur für ein CPU-Typ gültig sind und es nicht möglich ist eine Schlussfolgerung auf andere CPUs, der selben Modellreihe zu schliessen. Somit bleibt eine Verallgemeinerung im Bezug auf den Leistungsverbrauch der Befehlssätze aus. Die Resultate zeigt auch, dass grosse Differenzen existieren innerhalb eines Befehlssatz. Dabei spielt es eine grosse Rolle welche Zahlen eine Operation behandeln muss, wie grosse die zu behandelten Wortbreite ist oder in welchen Reihenfolge Befehlssätze durchlaufen müssen. Um ein Versuch einer Verallgemeinerung auf einer einzelne Hardware zu erstellen, müssten viel grössere Mengen an Benchmarks durchgeführt werden. Damit möglichst jeder Fall abgedeckt wird und sich daraus eine Verallgemeinerung aus dieser hohe Komplexität der Gestaltung der Befehlssätze erstellen würde. Eine andere Möglichkeit, ist ein bestimmten Algorithmus in einer Applikation zu Optimieren und dafür geeignete Benchmarks erstellen. Dieses Vorgehen hätte den Vorteil, dass man sich nicht auf eine aufwändige Verallgemeinerung stützt, sondern sich auf eine bestimmte stelle im Programmcode der Applikation konzentriert. Die Optimierung würde dort statt finden wo vorhersehbar ist, dass ein Programm an einer bestimmter Stelle sehr viele Male durchläuft.

\section{Bestimmung des EPI}
\label{sec:bestimmung_grundenergie}

Ein Benchmark besteht aus einer Schleife die ein gewünschter Befehlssatz eine hohe Anzahl wiederholt wird, damit dieser im Bezug auf die Energie gemessen werden kann. Um den Energieverbrauch eines einzelnen Befehlssatz (EPI) zu bestimmen, muss die Anzahl der Schleifendurchläufe durch die gesamte Energie geteilt werden. Das Problem liegt daran, dass die Schleife selbst eine gewisse Energie Aufweist die dem Endresultat abgezogen werden muss. Die Grundenergie der Schleife zu messen zeichnet sich als sehr schwierig aus. Eine Möglichkeit ist eine Benchmark zu erstellen der kein zu testender Befehlssatz beinhaltet und dieser als Referenz zur Bestimmung der Grundenergie zu benutzen. Es müssen aber etliche Versuche statt finden um zu beweisen, dass es sich wirklich um die Grundenergie der Schleife handelt und zur Berechnung der EPI verwendet werden darf.
\par
Ein Andere Ansatz sind die Benchmarks gegen übereinander zu vergleichen ohne dem genaue EPI zu berechnen. Grundsätzlich reicht bereits die Information aus, dass ein Befehlssatz sparsamer ist als ein anderer. Angenommen ein Benchmark besteht aus $x_1 + b + x_2$ und mit $x_1 + a + x_2$ der Vergleichsbenchmark. Mit $x_1$ und $x_2$ wir der Verbrauch der Schleife bestimmt der anfangs und ende der Schleife produziert wird. Man kann davon ausgehen, dass der Energieverbrauch der Schleife in beiden Benchmarks gleich hoch ist. Mit $a$ und $b$ wird die Energie des Befehlssatz innerhalb der Schleife bestimmt. So lässt es sich sagen, dass ein Benchmark gegenüber sein Vergleichsbenchmark $(x_1 + b + x_2) - (x_1 + a + x_2) = b - a$ ist. So kann ein Energieersparnis bestimmt werden, wenn eines Befehlssatz aus einem Algorithmus durch ein alternativ Befehlssatz ausgewechselt wird.



\section{Einfluss der CPU-Zyklen auf die Energie}
% Best Performance decrease cpu cycles
Die grösste Energieeinsparung erhält man wann man Befehlssätze verwendet, die möglichst geringe CPU-Zyklen für die Ausführung benötigen. Dies haben die Berechnungen aus den Auswertungen auf dem Galileo und Raspberry Board gezeigt, wenn man die Energie aus Leistung und Durchlaufzeit nimmt. Ein Befehlssatz der nur ein CPU-Zyklus anstelle von zwei verwendet hat folglich eine Einsparung von fast 50\%. Dies hat als neben Effekt nicht nur die Energieeinsparung zur Folge, sonder auch ein schnelleres abarbeiten einer Prozedur. Und deshalb sollte dies Ziel immer angestrebt werden.

\section{Theoretisches Sparpotenzial}
Um eine Ahnung zu erhalten wie weit die Energieersparnis, bei optimierte Algorithmen liegt, kann man folgende Theorie aufstellen. Wird die grösste Differenz des Energieverbrauch zweier Benchmarks genommen, erhält man einen ungefähren Wert wo das Potenzial liegen könnte. Dabei muss beachtet werden dass, die Anzahl der Durchläufe auf dem zu optimierenden Algorithmus entsprechend Hochgerechnet werden muss. Dieser Wert bleibt nur ein theoretischer Wert, denn wie im \autoref{sec:alternative_befehlsaetze} erwähnt muss ein alternativer Befehlssatz gefunden werden. Die Werte in \autoref{fig:energysave_table} wurden anhand der Bestehenden Benchmarks\footnote{Siehe Tabelle im Anhang. Kap. 1.2 und Kap.2.2. Die \texttt{nop} Benchmarks wurden ausgeschlossen} erstellt, es ist Wahrscheinlich, dass durch eine höhere Anzahl an Benchmarks grössere Differenzen gefunden werden können.


\begin{figure}[H]
\center
\begin{tabular}{ |l|l|l|l| }
\hline
Board & Min/Max (mW/h) & Durchläufe & Differenz (mW/h) \\ \hhline{|=|=|=|=|}
\multirow{2}{*}{Galileo} & 89.5 & \multirow{2}{*}{$\approx$6.4 Mrd.} & \multirow{2}{*}{49.7} \\ 
 & 139.2 & &  \\ \hline
\multirow{2}{*}{Raspberry} & 66.9 & \multirow{2}{*}{$\approx$21.4 Mrd.} & \multirow{2}{*}{10.8} \\ 
 & 77.7 & &  \\
\hline
\end{tabular}
\caption{Theoretische Energieeinsparung}
\label{fig:energysave_table}
\end{figure}


\section{Alternative Befehlssätze}
\label{sec:alternative_befehlsaetze}
Bei allen Optimierungen bleibt die Frage offen, ob es für einen Energie verschwenderischen Befehlssatz sich eine gleichwertige alternative finden lässt. Diese Frage hängt sehr stark nach der Anforderung des Programmcode ab. Es ist durchaus denkbar das zweifache eines Wert durch eine Multiplikation oder durch eine binäre Verschiebung mit dem selben Resultat zu erreichen. Falls die Wortlänge nicht 16 Bit überschreitet könnte anstelle des Befehlssatz \texttt{add} auch \texttt{sadd16} für die Erzeugung des selben Resultates verwendet werden. Es ist also möglich alternative Befehlssätze zu finden, es verlangt aber sehr starke engineering Arbeit und muss für jeden Anwendungsfall individuell gelöst werden.


\section{Messmethodik}
Eine positive Eigenschaft der Messmethode liegt darin, dass der zu prüfender Teil des Benchmarks in Assemblercode geschrieben werden können. Dadurch lässt es sich, mit grosser Freiheit, exakt definierte Benchmarks erstellen. Die Kontrolle des Ablaufs eines Benchmarks liegt stets beim Programmierer. Die Rückschlüsse auf das Verhalten eines Benchmarks können mittels Dokumentation, Beobachtung und Analyse vollzogen werden. Die Rückschlüsse erfordern zum teil sehr viel Zeitaufwand.
\par
Die Benchmarks innerhalb eines Kernelmodul zu starten hat sich als sehr als praktisch erwiesen. Mit dieser Methode kann der CPU durch ein Linux-Betriebssystem gestartet werden, bis vor und nach der Ausführung des Benchmarks kann das Betriebssystem vollumfänglich benützt werden. Nachteilig ist das Aufwändige aufsetzen der Entwicklungsumgebung für die Erstellung der Benchmarks. Da es sich um ein Kernel handelt, müssen während der Kompilierung die Linux-Headers vorhanden sein. Werden die Benchmarks cross-compiliert, dies heisst sie werden auf einem anderen Computer mit einem unterschiedlichen Betriebssystem kompiliert, müssen die Linux-Header auf diese vorbereitet werden. Für die Vorbereitung muss der passende Kernel kompiliert und mit den richtigen Flags konfiguriert werden. Für das Raspberry Board muss sogar ein spezieller GCC verwendet werden. Ist einmal die Entwicklungsumgebung hergestellt, können die Benchmarks sehr schnell erstellt werden. Der Sourcecode ist so aufgebaut das sich die Benchmarks nur durch eine Konfigurationsdatei definieren lassen und das ganze Softwaregerüst drumherum automatisch gebaut wird und anschliessend kompiliert wird.
\par
Die automatisierter Messung hat sich während der Arbeit Positiv ausgewirkt. So können effizient eine grosse Mengen an Benchmarks durchlaufen werden. Die Automatisierung ermöglicht es auf Einfacherweise die Benchmarks mehrfach auszuführen und auf ein wiederholtes Resultat zu prüfen.
\par
Die Messung am Eingang des Board vorzunehmen, heisst dass die gesamte Leistung dessen gemessen wird und eine Grundleistung der umliegende Komponente im Resultat enthalten sein wird. Die Grundleistung einzubeziehen kann als wünschenswert oder störend erachtet werden, da es darauf ankommt was man als Endresultat erreichten will. Die hier ausgeführten Benchmarks wurden nicht direkt am CPU gemessen und dadurch erhält man die effektive Leistung, dass der Prozessor und die Umliegende Komponente benötigen. Wird die gesamte Leistung gemessen können die Umliegende Komponente Schwankungen verursachen, in dem sie die Messung durch unkontrollierbares Verhalten verfälschen. Auf SoC sind diese Komponente sehr klein und durch eine mehrfache Messung konnte gezeigt werden dass diese kaum die Messung beeinflussen. Auf grössere Systeme, wie bereits ein PC oder ein Server sind Festplatten, Lüfter oder Kommunikationsschnittstellen, verbaut. Deshalb muss überprüft werden wie gross diese Komponente auf die Messung Einflussnehmen. Gegebenenfalls müssten solche während der Messung deaktiviert oder entfernt werden. Für den reinen Leistungsverbrauch des CPU zu bestimmen, muss ein Weg gefunden werden die Messung direkt an dieser Vorzunehmen. Dabei könnte die Messung über eine thermische Kamera erfolgen. Die Methodik wurde in der Arbeit "Measuring Power and Temperatur from Real Prozessor"\cite{measuring_power_temperature,} von Francisco J. Mesa-Martinez,  Michael Brown, Joesph  Nayfach-Battilana und Jose Renau beschrieben.


\section{Abschliessendes Fazit}
Aus der Diskussion wird gezeigt, dass sich die Messmethodik mit den Benchmarks sowie die dazugehörige Automatisierung gut geeignet hat, weil so effizient Resultate erzielt werden konnte. Es zeigte sich dass für ein Verallgemeinerung der Aussage, wie viel Energie ein Befehlssatz braucht, viel grössere Menge an Benchmarks erstellt werden muss. Weil dies unter Berücksichtigung, des CPU-Typ und dessen Architektur, Grösse des Operand und Anzahl der CPU-Zyklus das ein Befehlssatz benötigt, erfolgen muss. Die Energieersparnis eines einzelnen Befehlssatz ist sehr klein. Deshalb sind Algorithmen ideal die eine hohe Durchlaufzahl an der selbe stelle im Sourcecode aufweisen, so lässt sich auch Punktuell optimieren und nur einen bestimmten Bereich analysieren. Die grösste Einsparung erhält man wenn man Befehlssätze anwendet die eine niedrige Anzahl an CPU-Zyklen aufweisen. Ein Energieersparnis kann für ein Algorithmus durch Optimierte Befehlssätze erzielt werden, wenn dafür Alternative Befehlssätze gefunden werden können.
