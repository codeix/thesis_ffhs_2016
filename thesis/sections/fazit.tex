\chapter{Diskussion}

In diesem Kapitel wird aufgezeigt, welche Schlüsse und Interpretationen aus der Auswertung der Resultate gezogen werden können. Es werden zudem die Vor- und Nachteile der Messmethodik dargelegt. Zusätzlich werden potenzielle, auf dieser Arbeit aufbauende Forschungsziele vorgestellt.

\section{Einfluss der unterschiedlichen CPU-Architekturen auf den Energieverbrauch}
Im Bezug auf die Umwelt und das Streben nach einer Energieeinsparung, zeigt diese Arbeit, dass es durchaus möglich ist, einzelne Befehlssätze zu messen und auszuwerten. Sie legt aber ebenso dar, wie unterschiedlich die verschiedenen Architekturen sind und wie sich dies auf die Benchmarks auswirkt. Diese Tatsache spiegelt sich in den komplett differenzierten Resultaten der beiden verwendeten Boards wider. Es ist anzunehmen, dass die erzeugten Daten der Benchmarks nur für einen CPU-Typ Gültigkeit erlangen. Es ist unmöglich, eine Schlussfolgerung für andere CPUs derselben Modellreihe zu ziehen. Infolgedessen bleibt eine Verallgemeinerung in Bezug auf den Leistungsverbrauch der Befehlssätze aus. Die Resultate zeigen ebenfalls auf, dass grosse Differenzen innerhalb eines Befehlssatz existieren. Dabei spielt es vor allem eine zentrale Rolle, welche Zahlen eine Operation behandeln muss, wie gross die zu behandelnde Wortbreite ist oder in welcher Reihenfolge, Befehlssätze durchlaufen werden müssen. Um trotzdem eine globale Schlussfolgerung für eine einzelne Hardware ziehen zu können, müssten viel grössere Mengen an Benchmarks durchgeführt werden. Nur so wäre es realistisch, möglichst jeden Fall abzudecken und daraus eine Verallgemeinerung für die komplexe Aufgabe der Gestaltung der Befehlssätze ableiten zu können. Eine andere Möglichkeit bestünde darin, einen bestimmten Algorithmus in einer Applikation zu optimieren und dafür geeignete Benchmarks zu erstellen. Dieses Vorgehen hätte den Vorteil, dass man sich auf eine bestimmte Stelle im Programmcode der Applikation konzentriert, anstatt sich auf eine aufwendige Verallgemeinerung zu stützen. Die Optimierung würde genau an der Stelle stattfinden, wo vorhersehbar ist, dass ein Programm sehr viele Male durchläuft.

\section{Bestimmung des EPI-Verbrauchs}
\label{sec:bestimmung_grundenergie}

Aufgrund der aufwendigen Schritte wurde der EPI-Verbrauch, welcher aus den Resultaten der Messungen ermittelt werden kann, nicht bis zum Schluss berechnet. Die Rückschlüsse konnten auch ohne den exakt berechneten EPI-Verbrauch gezogen werden. Ein Benchmark besteht aus einer Schleife, die den ausgewählten Befehlssatz in einer hohen Anzahl wiederholt, damit dieser in Bezug auf die erforderliche Energie gemessen werden kann. Um den Energieverbrauch eines einzelnen Befehlssatzes (EPI) zu bestimmen, muss die Anzahl der Schleifendurchläufe durch die gesamte Energie geteilt werden. Das Problem liegt darin, dass die Schleife selbst eine gewisse Grundenergie aufweist, die vom Endresultat abgezogen werden muss. Diese zu messen, stellt eine grosse Herausforderung dar. Dafür können zwei Ansätze weiterverfolgt werden:
\begin{description}
\item[Ansatz 1:]
Es wird ein Benchmark erstellt, der keinen zu testenden Befehlssatz beinhaltet. Dieser wird als Referenz zur Bestimmung der Grundenergie benutzt. Um zu beweisen, dass es sich dabei tatsächlich um die Grundenergie der Schleife handelt, die zur Berechnung der EPI-Verbrauchs verwendet werden darf, müssen jedoch etliche Versuche stattfinden. Dies trägt zur Erschwernis des ganzen Berechnungsprozesses bei. 
\par
\item[Ansatz 2:]
Ein anderer Ansatz wird verfolgt, wenn die Benchmarks miteinander verglichen werden, ohne den genauen EPI-Verbrauch zu berechnen. Grundsätzlich reicht bereits die Information, dass ein Befehlssatz sparsamer als ein anderer ist, aus, um gewisse Schlüsse zu ziehen. Angenommen ein Benchmark besteht aus $x_1 + b + x_2$ und der Vergleichsbenchmark aus $x_1 + a + x_2$. Mit $x_1$ und $x_2$ wird der Verbrauch der Schleife bestimmt, der am Anfang und Ende der Schleife produziert wird. Man kann davon ausgehen, dass der Energieverbrauch der Schleife in beiden Benchmarks gleich hoch ist. Mit $a$ und $b$ wird der Energieverbrauch des jeweiligen Befehlssatzes innerhalb der Schleife bezeichnet. So lässt sich bestimmen, wie sich ein Benchmark gegenüber seinem Vergleichsbenchmark verhält; und zwar folgendermassen: $(x_1 + b + x_2) - (x_1 + a + x_2) = b - a$. Wird demzufolge ein Befehlssatz aus einem Algorithmus durch einen alternativen ersetzt, kann so die Energieersparnis ermittelt werden.
\end{description}


\section{Einfluss der CPU-Zyklen auf den Energieverbrauch}
% Best Performance decrease cpu cycles
Die grösste Energieeinsparung ist realisierbar, wenn man Befehlssätze verwendet, die eine möglichste geringe Anzahl an CPU-Zyklen für die Ausführung benötigen. Dies haben die Berechnungen der Energie aus Leistung und Durchlaufzeit   des Galileo- und Raspberry Pi-Boards gezeigt. Ein Befehlssatz, der nur ein CPU-Zyklus anstelle von zwei verwendet, generiert folglich eine Einsparung von fast 50 Prozent. Dies hat nicht nur eine Energieeinsparung zur Folge, sondern als Nebeneffekt auch ein schnelleres Abarbeiten der Prozedur. Deshalb sollte die Verringerung der Anzahl der erforderlichen CPU-Zyklen immer als Ziel angestrebt werden.

\section{Theoretisches Sparpotenzial}
Um eine Ahnung zu erhalten, wie hoch die Energieersparnis mit optimierten Algorithmen ausfallen kann, muss die folgende Annahme getroffen werden. Wird die grösste Differenz des Energieverbrauchs zweier Benchmarks genommen, erhält man einen ungefähren Wert über den Umfang des Sparpotenzials. Dabei ist zu beachten, dass die Anzahl der Durchläufe auf dem zu optimierenden Algorithmus entsprechend hochgerechnet werden. Dieser Wert bleibt ein rein theoretischer. Denn wie in \autoref{sec:alternative_befehlsaetze} erwähnt, muss ein alternativer Befehlssatz gefunden werden, um das tatsächliche Sparpotenzial festzustellen. Die Werte in \autoref{fig:energysave_table} wurden anhand der bestehenden Benchmarks\footnote{Siehe die Tabelle im Anhang in Kap. 1.25. Die \texttt{nop} Benchmarks wurden zur Berechnung der Werte in Abbildung 7.1 nicht verwendet.} erstellt. Es ist wahrscheinlich, dass durch die Verwendung einer umfangreicheren Anzahl von Benchmarks grössere Differenzen gefunden werden können.


\begin{figure}[H]
\center
\begin{tabular}{ |l|l|l|l| }
\hline
Board & Min/Max (mW/h) & Durchläufe & Differenz (mW/h) \\ \hhline{|=|=|=|=|}
\multirow{2}{*}{Galileo} & 89.5 & \multirow{2}{*}{$\approx$6.4 Mrd.} & \multirow{2}{*}{49.7} \\ 
 & 139.2 & &  \\ \hline
\multirow{2}{*}{Raspberry} & 66.9 & \multirow{2}{*}{$\approx$21.4 Mrd.} & \multirow{2}{*}{10.8} \\ 
 & 77.7 & &  \\
\hline
\end{tabular}
\caption{Theoretische Energieeinsparung}
\label{fig:energysave_table}
\end{figure}


\section{Alternative Befehlssätze}
\label{sec:alternative_befehlsaetze}
Bei allen Optimierungen bleibt die Frage offen, ob es für einen Energie verschwenderischen Befehlssatz sich eine gleichwertige alternative finden lässt. Diese Frage hängt sehr stark nach der Anforderung des Programmcode ab. Es ist durchaus denkbar das zweifache eines Wert durch eine Multiplikation oder durch eine binäre Verschiebung mit dem selben Resultat zu erreichen. Falls die Wortlänge nicht 16 Bit überschreitet könnte anstelle des Befehlssatz \texttt{add} auch \texttt{sadd16} für die Erzeugung des selben Resultates verwendet werden. Es ist also möglich alternative Befehlssätze zu finden, es verlangt aber sehr starke engineering Arbeit und muss für jeden Anwendungsfall individuell gelöst werden.


\section{Messmethodik}
Eine positive Eigenschaft der Messmethode liegt darin, dass der zu prüfender Teil des Benchmarks in Assemblercode geschrieben werden können. Dadurch lässt es sich, mit grosser Freiheit, exakt definierte Benchmarks erstellen. Die Kontrolle des Ablaufs eines Benchmarks liegt stets beim Programmierer. Die Rückschlüsse auf das Verhalten eines Benchmarks können mittels Dokumentation, Beobachtung und Analyse vollzogen werden. Die Rückschlüsse erfordern zum teil sehr viel Zeitaufwand.
\par
Die Benchmarks innerhalb eines Kernelmodul zu starten hat sich als sehr als praktisch erwiesen. Mit dieser Methode kann der CPU durch ein Linux-Betriebssystem gestartet werden, bis vor und nach der Ausführung des Benchmarks kann das Betriebssystem vollumfänglich benützt werden. Nachteilig ist das Aufwändige aufsetzen der Entwicklungsumgebung für die Erstellung der Benchmarks. Da es sich um ein Kernel handelt, müssen während der Kompilierung die Linux-Headers vorhanden sein. Werden die Benchmarks cross-compiliert, dies heisst sie werden auf einem anderen Computer mit einem unterschiedlichen Betriebssystem kompiliert, müssen die Linux-Header auf diese vorbereitet werden. Für die Vorbereitung muss der passende Kernel kompiliert und mit den richtigen Flags konfiguriert werden. Für das Raspberry Board muss sogar ein spezieller GCC verwendet werden. Ist einmal die Entwicklungsumgebung hergestellt, können die Benchmarks sehr schnell erstellt werden. Der Sourcecode ist so aufgebaut das sich die Benchmarks nur durch eine Konfigurationsdatei definieren lassen und das ganze Softwaregerüst drumherum automatisch gebaut wird und anschliessend kompiliert wird.
\par
Die automatisierter Messung hat sich während der Arbeit Positiv ausgewirkt. So können effizient eine grosse Mengen an Benchmarks durchlaufen werden. Die Automatisierung ermöglicht es auf Einfacherweise die Benchmarks mehrfach auszuführen und auf ein wiederholtes Resultat zu prüfen.
\par
Die Messung am Eingang des Board vorzunehmen, heisst dass die gesamte Leistung dessen gemessen wird und eine Grundleistung der umliegende Komponente im Resultat enthalten sein wird. Die Grundleistung einzubeziehen kann als wünschenswert oder störend erachtet werden, da es darauf ankommt was man als Endresultat erreichten will. Die hier ausgeführten Benchmarks wurden nicht direkt am CPU gemessen und dadurch erhält man die effektive Leistung, dass der Prozessor und die Umliegende Komponente benötigen. Wird die gesamte Leistung gemessen können die Umliegende Komponente Schwankungen verursachen, in dem sie die Messung durch unkontrollierbares Verhalten verfälschen. Auf SoC sind diese Komponente sehr klein und durch eine mehrfache Messung konnte gezeigt werden dass diese kaum die Messung beeinflussen. Auf grössere Systeme, wie bereits ein PC oder ein Server sind Festplatten, Lüfter oder Kommunikationsschnittstellen, verbaut. Deshalb muss überprüft werden wie gross diese Komponente auf die Messung Einflussnehmen. Gegebenenfalls müssten solche während der Messung deaktiviert oder entfernt werden. Für den reinen Leistungsverbrauch des CPU zu bestimmen, muss ein Weg gefunden werden die Messung direkt an dieser Vorzunehmen. Dabei könnte die Messung über eine thermische Kamera erfolgen. Die Methodik wurde in der Arbeit "Measuring Power and Temperatur from Real Prozessor"\cite{measuring_power_temperature,} von Francisco J. Mesa-Martinez,  Michael Brown, Joesph  Nayfach-Battilana und Jose Renau beschrieben.


\section{Abschliessendes Fazit}
Aus der Diskussion wird gezeigt, dass sich die Messmethodik mit den Benchmarks sowie die dazugehörige Automatisierung gut geeignet hat, weil so effizient Resultate erzielt werden konnte. Es zeigte sich dass es für eine Verallgemeinerung der Aussage, wie viel Energie ein Befehlssatz braucht, eine viel grössere Menge an Benchmarks erstellt werden muss. Weil dies unter Berücksichtigung, des CPU-Typ und dessen Architektur, Grösse des Operand und Anzahl der CPU-Zyklus das ein Befehlssatz benötigt, erfolgen muss. Die Energieersparnis eines einzelnen Befehlssatz ist sehr klein. Deshalb sind Algorithmen ideal die eine hohe Durchlaufzahl an der selbe stelle im Sourcecode aufweisen, so lässt sich auch Punktuell optimieren und nur einen bestimmten Bereich analysieren. Die grösste Einsparung erhält man wenn man Befehlssätze anwendet die eine niedrige Anzahl an CPU-Zyklen aufweisen. Ein Energieersparnis kann für ein Algorithmus durch Optimierte Befehlssätze erzielt werden, wenn dafür Alternative Befehlssätze gefunden werden können.
