\chapter{Diskussion}

In diesem Kapitel wird aufgezeigt, welche Schlüsse und Interpretationen aus der Auswertung der Resultate gezogen werden können. Es werden zudem die Vor- und Nachteile der Messmethodik dargelegt. Zusätzlich werden potenzielle, auf dieser Arbeit aufbauende Forschungsziele vorgestellt.

\section{Einfluss der unterschiedlichen CPU-Architekturen auf den Energieverbrauch}
Im Bezug auf die Umwelt und das Streben nach einer Energieeinsparung, zeigt diese Arbeit, dass es durchaus möglich ist, einzelne Befehlssätze zu messen und auszuwerten. Sie legt aber ebenso dar, wie unterschiedlich die verschiedenen Architekturen sind und wie sich dies auf die Benchmarks auswirkt. Diese Tatsache spiegelt sich in den komplett differenzierten Resultaten der beiden verwendeten Boards wider. Es ist anzunehmen, dass die erzeugten Daten der Benchmarks nur für einen CPU-Typ Gültigkeit erlangen. Es ist unmöglich, eine Schlussfolgerung für andere CPUs derselben Modellreihe zu ziehen. Infolgedessen bleibt eine Verallgemeinerung in Bezug auf den Leistungsverbrauch der Befehlssätze aus. Die Resultate zeigen ebenfalls auf, dass grosse Differenzen innerhalb eines Befehlssatz existieren. Dabei spielt es vor allem eine zentrale Rolle, welche Zahlen eine Operation behandeln muss, wie gross die zu behandelnde Wortbreite ist oder in welcher Reihenfolge, Befehlssätze durchlaufen werden müssen. Um trotzdem eine globale Schlussfolgerung für eine einzelne Hardware ziehen zu können, müssten viel grössere Mengen an Benchmarks durchgeführt werden. Nur so wäre es realistisch, möglichst jeden Fall abzudecken und daraus eine Verallgemeinerung für die komplexe Aufgabe der Gestaltung der Befehlssätze ableiten zu können. Eine andere Möglichkeit bestünde darin, einen bestimmten Algorithmus in einer Applikation zu optimieren und dafür geeignete Benchmarks zu erstellen. Dieses Vorgehen hätte den Vorteil, dass man sich auf eine bestimmte Stelle im Programmcode der Applikation konzentriert, anstatt sich auf eine aufwendige Verallgemeinerung zu stützen. Die Optimierung würde genau an der Stelle stattfinden, wo vorhersehbar ist, dass ein Programm sehr viele Male durchläuft.

\section{Bestimmung des EPI-Verbrauchs}
\label{sec:bestimmung_grundenergie}

Aufgrund der aufwendigen Schritte wurde der EPI-Verbrauch, welcher aus den Resultaten der Messungen ermittelt werden kann, nicht bis zum Schluss berechnet. Die Rückschlüsse konnten auch ohne den exakt berechneten EPI-Verbrauch gezogen werden. Ein Benchmark besteht aus einer Schleife, die den ausgewählten Befehlssatz in einer hohen Anzahl wiederholt, damit dieser in Bezug auf die erforderliche Energie gemessen werden kann. Um den Energieverbrauch eines einzelnen Befehlssatzes (EPI) zu bestimmen, muss die Anzahl der Schleifendurchläufe durch die gesamte Energie geteilt werden. Das Problem liegt darin, dass die Schleife selbst eine gewisse Grundenergie aufweist, die vom Endresultat abgezogen werden muss. Diese zu messen, stellt eine grosse Herausforderung dar. Dafür können zwei Ansätze weiterverfolgt werden:
\begin{description}
\item[Ansatz 1:]
Es wird ein Benchmark erstellt, der keinen zu testenden Befehlssatz beinhaltet. Dieser wird als Referenz zur Bestimmung der Grundenergie benutzt. Um zu beweisen, dass es sich dabei tatsächlich um die Grundenergie der Schleife handelt, die zur Berechnung der EPI-Verbrauchs verwendet werden darf, müssen jedoch etliche Versuche stattfinden. Dies trägt zur Erschwernis des ganzen Berechnungsprozesses bei. 
\par
\item[Ansatz 2:]
Ein anderer Ansatz wird verfolgt, wenn die Benchmarks miteinander verglichen werden, ohne den genauen EPI-Verbrauch zu berechnen. Grundsätzlich reicht bereits die Information, dass ein Befehlssatz sparsamer als ein anderer ist, aus, um das Optimierungspotential eines beliebigen Sourcecodes zu erkennen. Angenommen ein Benchmark besteht aus $x_1 + b + x_2$ und der Vergleichsbenchmark aus $x_1 + a + x_2$. Mit $x_1$ und $x_2$ wird der Verbrauch der Schleife bestimmt, der am Anfang und Ende der Schleife produziert wird. Man kann davon ausgehen, dass der Energieverbrauch der Schleife in beiden Benchmarks gleich hoch ist. Mit $a$ und $b$ wird der Energieverbrauch des jeweiligen Befehlssatzes innerhalb der Schleife bezeichnet. So lässt sich bestimmen, wie sich ein Benchmark gegenüber seinem Vergleichsbenchmark verhält; und zwar folgendermassen: $(x_1 + b + x_2) - (x_1 + a + x_2) = b - a$. Wird demzufolge ein Befehlssatz aus einem Algorithmus durch einen alternativen ersetzt, kann so die Energieersparnis ermittelt werden.
\end{description}


\section{Einfluss der CPU-Zyklen auf den Energieverbrauch}
% Best Performance decrease cpu cycles
Die grösste Energieeinsparung ist realisierbar, wenn man Befehlssätze verwendet, die eine möglichste geringe Anzahl an CPU-Zyklen für die Ausführung benötigen. Dies haben die Berechnungen der Energie aus Leistung und Durchlaufzeit   des Galileo- und Raspberry Pi-Boards gezeigt. Ein Befehlssatz, der nur ein CPU-Zyklus anstelle von zwei verwendet, generiert folglich eine Einsparung von fast 50 Prozent. Dies hat nicht nur eine Energieeinsparung zur Folge, sondern als Nebeneffekt auch ein schnelleres Abarbeiten der Prozedur. Deshalb sollte die Verringerung der Anzahl der erforderlichen CPU-Zyklen immer als Ziel angestrebt werden.

\section{Theoretisches Sparpotenzial}
Um eine Ahnung zu erhalten, wie hoch die Energieersparnis mit optimierten Algorithmen ausfallen kann, muss die folgende Annahme getroffen werden. Wird die grösste Differenz des Energieverbrauchs zweier Benchmarks genommen, erhält man einen ungefähren Wert über den Umfang des Sparpotenzials. Dabei ist zu beachten, dass die Anzahl der Durchläufe auf dem zu optimierenden Algorithmus entsprechend hochgerechnet werden. Dieser Wert bleibt ein rein theoretischer. Denn wie in \autoref{sec:alternative_befehlsaetze} erwähnt, muss ein alternativer Befehlssatz gefunden werden, um das tatsächliche Sparpotenzial festzustellen und in der Folge zu realisieren. Die Werte in \autoref{tab:energysave_table} wurden anhand der bestehenden Benchmarks\footnote{Siehe die Tabellen im Anhang in den Kap. 1.2 und 2.2. Die \texttt{nop} Benchmarks wurden zur Berechnung der Werte in Abbildung 7.1 nicht verwendet.} erstellt. Es ist wahrscheinlich, dass durch die Verwendung einer umfangreicheren Anzahl von Benchmarks grössere Differenzen gefunden werden können.


\begin{table}[H]
\center
\begin{tabular}{ |l|l|l|l| }
\hline
Board & Min/Max (mW/h) & Durchläufe & Differenz (mW/h) \\ \hhline{|=|=|=|=|}
\multirow{2}{*}{Galileo} & 89.5 & \multirow{2}{*}{$\approx$6.4 Mrd.} & \multirow{2}{*}{49.7} \\ 
 & 139.2 & &  \\ \hline
\multirow{2}{*}{Raspberry} & 66.9 & \multirow{2}{*}{$\approx$21.4 Mrd.} & \multirow{2}{*}{10.8} \\ 
 & 77.7 & &  \\
\hline
\end{tabular}
\caption{Theoretische Energieeinsparung}
\label{tab:energysave_table}
\end{table}


\section{Alternative Befehlssätze}
\label{sec:alternative_befehlsaetze}
Bei allen Optimierungen bleibt die Frage offen, ob sich für einen Energie verschwendenden Befehlssatz eine energieeffizientere, jedoch gleichgerichtete Alternative finden lässt. Beispielsweise ist es durchaus denkbar, dass dasselbe Resultat, hier das Zweifache eines Wertes, sowohl durch eine Multiplikation wie auch durch eine binäre Verschiebung erreicht werden kann. Falls die Wortlänge 16bit nicht überschreitet, könnte anstelle des Befehlssatzes \texttt{add} auch \texttt{sadd16} für die Erzeugung desselben Resultates verwendet werden. Die Frage, ob es sich dabei jedoch tatsächlich um einen energieeffizienteren Befehlssatz handelt, hängt sehr stark von den Anforderungen ab, die an den Programmcode gestellt werden. Kurz gesagt, ist es zwar möglich, alternative Befehlssätze zu finden, jedoch verlangt es massive Engineeringarbeit und muss für jeden Anwendungsfall individuell gelöst werden.


\section{Messmethodik}
Eine positive Eigenschaft der Messmethode liegt darin begründet, dass der zu prüfende Teil des Benchmarks in Assemblercode geschrieben werden kann. Dadurch besteht die Möglichkeit, trotz grosser Freiheit exakt definierte Benchmarks zu erstellen. Die Kontrolle des Ablaufs eines Benchmarks liegt stets beim Programmierer. Mittels Dokumentation, Beobachtung und Analyse können Rückschlüsse auf das Verhalten eines Benchmarks gezogen werden. Der einzige Nachteil besteht darin, dass das Ziehen der Rückschlüsse zum Teil sehr viel Zeitaufwand erfordert.
\par
Die Benchmarks innerhalb eines Kernelmoduls starten zu können, hat sich als sehr praktisch erwiesen. Mit dieser Methode kann die CPU durch ein Linux-Betriebssystem in Gang gebracht werden. Zudem kann das Betriebssystem bis vor und nach der Ausführung des Benchmarks vollumfänglich benützt werden. Nachteilig ist das aufwendige Aufsetzen der Entwicklungsumgebung für die Erstellung der Benchmarks. Darunter fällt insbesondere das Kompilieren des passenden Kernels, einschliesslich der Bereitstellung der Headerfiles. Beim Raspberry Pi Board kommt noch das Installieren des modifizierten GCC hinzu. So sind die Voraussetzungen für ein späteres Cross-Kompilieren der Benchmarks gegeben. Ist die Entwicklungsumgebung einmal aufgebaut, können die Benchmarks sehr schnell erzeugt werden. Der Sourcecode ist so konzeptioniert, dass sich die Benchmarks nur durch eine Konfigurationsdatei definieren lassen. Beim nachfolgenden Kompilieren des Kernelmoduls wird dann das ganze, darumliegende Softwaregerüst automatisch gebaut .
\par
Die automatisierter Messung hat sich während der Arbeit positiv ausgewirkt. So konnte man eine grosse Mengen an Benchmarks effizient durchlaufen lassen. Die Automatisierung ermöglicht es, die Benchmarks auf einfache Art und Weise mehrfach auszuführen und die sich wiederholten Resultate auf ihre Beständigkeit zu überprüfen.
\par
Die Messung des Energieverbrauchs der Benchmarks kann am Eingang des Boards oder direkt an der CPU vorgenommen werden. Die Messung am Eingang des Boards vorzunehmen, bedeutet, dass dessen gesamte Leistungsaufnahme gemessen wird. Im Resultat ist somit neben der effektiven Leistungsaufnahme des Prozessors auch die Grundleistung der umliegenden Komponenten enthalten. Die Grundleistung in die Messung miteinzubeziehen, kann als wünschenswert oder störend erachtet werden, je nachdem, was man als Endresultat erhalten möchte. Wird die gesamte Leistungsaufnahme gemessen, können die umliegenden Komponenten Schwankungen im Energieverbrauch verursachen. Dieses unkontrollierbare Verhalten kann zu einer Verfälschung der Messresultate führen. Durch mehrfache Messungen konnte jedoch aufgezeigt werden, dass diese umliegenden Komponenten die Messung kaum beeinflussen. Dies liegt vor allem an der Tatsache, dass diese Komponenten bei SoC sehr gering ausfallen. Auf grösseren Systemen, wie einem PC oder einem Server, sind bereits von Anfang an Festplatten, Lüfter oder Kommunikationsschnittstellen verbaut. Um den reinen Leistungsverbrauch der CPU zu bestimmen, müsste daher gegebenenfalls ein Weg gefunden werden, die Messung direkt an der CPU vorzunehmen oder die umliegenden Komponenten während der Messung zu deaktivieren oder zu entfernen. Dies stellt sich als fast unmöglich dar. Deshalb muss bei grösseren Systemen in der Regel exakt festgestellt werden, wie gross der Einfluss der umliegenden Komponenten auf die Messung ist. Eine Möglichkeit, den Stromverbrauch dirket an der CPU eines grösseren Systems zu messen, bietet eine thermische Kamera. Diese Methodik wurde in der Arbeit "Measuring Power and Temperature from Real Processors"\cite{measuring_power_temperature} von Francisco J. Mesa-Martinez, Michael Brown, Joesph Nayfach-Battilana und Jose Renau beschrieben.


\section{Abschliessendes Fazit}
Aus der Diskussion wird deutlich, dass sich die Messmethodik mit den Benchmarks sowie der dazugehörigen Automatisierung gut eignet, weil damit effiziente Resultate erzielt werden konnte. Jedoch wurde auch aufgezeigt, dass für eine Verallgemeinerung der Aussage, wie viel Energie ein Befehlssatz benötigt, eine viel grössere Menge an Benchmarks erstellt werden müsste. Zusätzlich hängt die Aussage, ob und wie viel Energie pro Befehlssatz gespart werden kann, stark von dem CPU-Typ und dessen Architektur, der Grösse des Operands und der Anzahl der zu durchlaufenden CPU-Zyklen ab. Die Energieeinsparung eines einzelnen Befehlssatz ist in der Regel sehr gering. Deshalb ist es am sinnvollsten, wenn man bei Algorithmen, die eine hohe Durchlaufzahl an derselben Stelle im Sourcecode aufweisen, das Sparpotenzial ermittelt und dieses realisiert. Dies, indem man einen bestimmten Bereich des Sourcecodes genau analysiert und dort, wo es sinnvoll erscheint, punktuell Optimierungen vornimmt. Eine Optimierung kann dadurch erzielt werden, dass in einem Algorithmus die Energie verschwendenden Befehlssätze durch alternative, energieeffizientere ersetzt werden. Die grösste Energieeinsparung kann jedoch verwirklicht werden, wenn Befehlssätze angewendet werden, die eine niedrige Anzahl an CPU-Zyklen aufweisen. 
